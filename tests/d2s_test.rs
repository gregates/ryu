// Translated from C to Rust. The original C code can be found at
// https://github.com/ulfjack/ryu and carries the following license:
//
// Copyright 2018 Ulf Adams
//
// The contents of this file may be used under the terms of the Apache License,
// Version 2.0.
//
//    (See accompanying file LICENSE-Apache or copy at
//     http://www.apache.org/licenses/LICENSE-2.0)
//
// Alternatively, the contents of this file may be used under the terms of
// the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE-Boost or copy at
//     https://www.boost.org/LICENSE_1_0.txt)
//
// Unless required by applicable law or agreed to in writing, this software
// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.

#![allow(
    clippy::approx_constant,
    clippy::cast_lossless,
    clippy::float_cmp,
    clippy::int_plus_one,
    clippy::non_ascii_literal,
    clippy::unreadable_literal,
    clippy::unseparated_literal_suffix
)]

#[macro_use]
mod macros;

use ryu::raw;
use ryu::buffer::Sealed;
use core::mem::MaybeUninit;
use core::{slice, str};
use std::f64;

fn pretty(f: f64) -> String {
    let mut buffer = [MaybeUninit::<u8>::uninit(); 2000];
    if f.is_nonfinite() {
        return f.format_nonfinite().to_owned();
    }
    unsafe {
        let n = raw::format64(f, None, b'.', buffer.as_mut_ptr() as *mut u8);
        debug_assert!(n <= 2000);
        let slice = slice::from_raw_parts(buffer.as_ptr() as *const u8, n);
        str::from_utf8_unchecked(slice).to_owned()
    }
}

fn with_precision(f: f64, precision: usize) -> String {
    let mut buffer = [MaybeUninit::<u8>::uninit(); 2000];
    if f.is_nonfinite() {
        return f.format_nonfinite().to_owned();
    }
    unsafe {
        let n = raw::format64_fixed(f, precision, b'.', buffer.as_mut_ptr() as *mut u8);
        debug_assert!(n <= 2000);
        let slice = slice::from_raw_parts(buffer.as_ptr() as *const u8, n);
        str::from_utf8_unchecked(slice).to_owned()
    }
}

fn ieee_parts_to_double(sign: bool, ieee_exponent: u32, ieee_mantissa: u64) -> f64 {
    assert!(ieee_exponent <= 2047);
    assert!(ieee_mantissa <= (1u64 << 53) - 1);
    f64::from_bits(((sign as u64) << 63) | ((ieee_exponent as u64) << 52) | ieee_mantissa)
}

#[test]
fn test_ryu() {
    assert_eq!(pretty(0.3), "0.3");
    assert_eq!(pretty(1234000000000000.0), "1234000000000000");
    assert_eq!(pretty(1.234e16), "12340000000000000");
    assert_eq!(pretty(2.71828), "2.71828");
    assert_eq!(pretty(1.1e128), "110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
    assert_eq!(pretty(1.1e-64), "0.00000000000000000000000000000000000000000000000000000000000000011");
    assert_eq!(pretty(2.718281828459045), "2.718281828459045");
    assert_eq!(pretty(5e-324), "0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005");
    assert_eq!(pretty(1.7976931348623157e308), "179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
    assert_eq!(pretty(1.23e-3), "0.00123");
}

#[test]
fn test_precision() {
    assert_eq!(with_precision(0.3, 3), "0.300");
    assert_eq!(with_precision(0.3, 2), "0.30");
    assert_eq!(with_precision(0.3, 1), "0.3");
    assert_eq!(with_precision(0.3, 0), "0");
    assert_eq!(with_precision(0.666, 3), "0.666");
    assert_eq!(with_precision(0.666, 2), "0.67");
    assert_eq!(with_precision(0.666, 1), "0.7");
    assert_eq!(with_precision(0.666, 0), "1");
    assert_eq!(with_precision(14.17, 2), "14.17");
    assert_eq!(with_precision(423151.0000000000000001, 20), "423151.00000000000000000000");
    assert_eq!(with_precision(1234567890.1234567890, 10), "1234567890.1234567000");
    assert_eq!(with_precision(1234567890.9999990000, 5), "1234567891.00000");
    assert_eq!(with_precision(1234567890.9999990000, 6), "1234567890.999999");
    assert_eq!(with_precision(1234567890.9999990000, 10), "1234567890.9999990000");
    for i in 0..64 {
        assert_eq!(with_precision(1.1e-64, i), format!("{:.1$}", 0.0, i));
    }
    assert_eq!(with_precision(1.1e-64, 64), "0.0000000000000000000000000000000000000000000000000000000000000001");
    assert_eq!(with_precision(1.5e-64, 64), "0.0000000000000000000000000000000000000000000000000000000000000002");
    assert_eq!(with_precision(1.1e-64, 65), "0.00000000000000000000000000000000000000000000000000000000000000011");
    assert_eq!(with_precision(1234000000000000.0, 12), "1234000000000000.000000000000");
    assert_eq!(with_precision(1.7976931348623157e308, 3), "179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.000");
    assert_eq!(with_precision(1.7976931348623157e308, 9), "179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.000000000");
}

#[test]
fn test_random() {
    let n = if cfg!(miri) { 100 } else { 1000000 };
    let mut buffer = ryu::Buffer::new();
    for _ in 0..n {
        let f: f64 = rand::random();
        assert_eq!(f, buffer.format_finite(f).parse().unwrap());
    }
}

#[test]
#[cfg_attr(miri, ignore = "too slow for miri")]
fn test_non_finite() {
    for i in 0u64..1 << 23 {
        let f = f64::from_bits((((1 << 11) - 1) << 52) + (i << 29));
        assert!(!f.is_finite(), "f={}", f);
        ryu::Buffer::new().format_finite(f);
    }
}

#[test]
fn test_basic() {
    assert_eq!(pretty(0.0), "0");
    assert_eq!(pretty(-0.0), "-0");
    assert_eq!(pretty(1.0), "1");
    assert_eq!(pretty(-1.0), "-1");
    assert_eq!(pretty(f64::NAN.copysign(1.0)), "NaN");
    assert_eq!(pretty(f64::NAN.copysign(-1.0)), "NaN");
    assert_eq!(pretty(f64::INFINITY), "inf");
    assert_eq!(pretty(f64::NEG_INFINITY), "-inf");
}

#[test]
fn test_switch_to_subnormal() {
    assert_eq!(pretty(2.2250738585072014e-308), "0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000022250738585072014");
}

#[test]
fn test_min_and_max() {
    assert_eq!(f64::from_bits(0x7fefffffffffffff), 1.7976931348623157e308);
    assert_eq!(pretty(1.7976931348623157e308), "179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
    assert_eq!(f64::from_bits(1), 5e-324);
    assert_eq!(pretty(5e-324), "0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005");
}

#[test]
fn test_lots_of_trailing_zeros() {
    assert_eq!(pretty(2.9802322387695312e-8), "0.000000029802322387695312");
}

#[test]
fn test_regression() {
    assert_eq!(pretty(-2.109808898695963e16), "-21098088986959630");
    assert_eq!(pretty(4.940656e-318), "0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004940656");
    assert_eq!(pretty(1.18575755e-316), "0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000118575755");
    assert_eq!(pretty(2.989102097996e-312), "0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002989102097996");
    assert_eq!(pretty(9060801153433600.0), "9060801153433600");
    assert_eq!(pretty(4.708356024711512e18), "4708356024711512000");
    assert_eq!(pretty(9.409340012568248e18), "9409340012568248000");
    assert_eq!(pretty(1.2345678), "1.2345678");
}

#[test]
fn test_looks_like_pow5() {
    // These numbers have a mantissa that is a multiple of the largest power of
    // 5 that fits, and an exponent that causes the computation for q to result
    // in 22, which is a corner case for RyÅ«.
    assert_eq!(f64::from_bits(0x4830F0CF064DD592), 5.764607523034235e39);
    assert_eq!(pretty(5.764607523034235e39), "5764607523034235000000000000000000000000");
    assert_eq!(f64::from_bits(0x4840F0CF064DD592), 1.152921504606847e40);
    assert_eq!(pretty(1.152921504606847e40), "11529215046068470000000000000000000000000");
    assert_eq!(f64::from_bits(0x4850F0CF064DD592), 2.305843009213694e40);
    assert_eq!(pretty(2.305843009213694e40), "23058430092136940000000000000000000000000");
}

#[test]
fn test_output_length() {
    assert_eq!(pretty(1.0), "1"); // already tested in Basic
    assert_eq!(pretty(1.2), "1.2");
    assert_eq!(pretty(1.23), "1.23");
    assert_eq!(pretty(1.234), "1.234");
    assert_eq!(pretty(1.2345), "1.2345");
    assert_eq!(pretty(1.23456), "1.23456");
    assert_eq!(pretty(1.234567), "1.234567");
    assert_eq!(pretty(1.2345678), "1.2345678");
    assert_eq!(pretty(1.23456789), "1.23456789");
    assert_eq!(pretty(1.234567890), "1.23456789");
    assert_eq!(pretty(1.234567895), "1.234567895");
    assert_eq!(pretty(1.2345678901), "1.2345678901");
    assert_eq!(pretty(1.23456789012), "1.23456789012");
    assert_eq!(pretty(1.234567890123), "1.234567890123");
    assert_eq!(pretty(1.2345678901234), "1.2345678901234");
    assert_eq!(pretty(1.23456789012345), "1.23456789012345");
    assert_eq!(pretty(1.234567890123456), "1.234567890123456");
    assert_eq!(pretty(1.2345678901234567), "1.2345678901234567");

    // Test 32-bit chunking
    check!(4.294967294); // 2^32 - 2
    check!(4.294967295); // 2^32 - 1
    check!(4.294967296); // 2^32
    check!(4.294967297); // 2^32 + 1
    check!(4.294967298); // 2^32 + 2
}

// Test min, max shift values in shiftright128
#[test]
fn test_min_max_shift() {
    let max_mantissa = (1u64 << 53) - 1;

    // 32-bit opt-size=0:  49 <= dist <= 50
    // 32-bit opt-size=1:  30 <= dist <= 50
    // 64-bit opt-size=0:  50 <= dist <= 50
    // 64-bit opt-size=1:  30 <= dist <= 50
    assert_eq!(1.7800590868057611E-307, ieee_parts_to_double(false, 4, 0));
    assert_eq!(pretty(1.7800590868057611e-307), "0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000017800590868057611");
    // 32-bit opt-size=0:  49 <= dist <= 49
    // 32-bit opt-size=1:  28 <= dist <= 49
    // 64-bit opt-size=0:  50 <= dist <= 50
    // 64-bit opt-size=1:  28 <= dist <= 50
    assert_eq!(
        2.8480945388892175E-306,
        ieee_parts_to_double(false, 6, max_mantissa)
    );
    assert_eq!(pretty(2.8480945388892175e-306), "0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000028480945388892175");
    // 32-bit opt-size=0:  52 <= dist <= 53
    // 32-bit opt-size=1:   2 <= dist <= 53
    // 64-bit opt-size=0:  53 <= dist <= 53
    // 64-bit opt-size=1:   2 <= dist <= 53
    assert_eq!(2.446494580089078E-296, ieee_parts_to_double(false, 41, 0));
    assert_eq!(pretty(2.446494580089078e-296), "0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002446494580089078");
    // 32-bit opt-size=0:  52 <= dist <= 52
    // 32-bit opt-size=1:   2 <= dist <= 52
    // 64-bit opt-size=0:  53 <= dist <= 53
    // 64-bit opt-size=1:   2 <= dist <= 53
    assert_eq!(
        4.8929891601781557E-296,
        ieee_parts_to_double(false, 40, max_mantissa)
    );
    assert_eq!(pretty(4.8929891601781557e-296), "0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000048929891601781557");

    // 32-bit opt-size=0:  57 <= dist <= 58
    // 32-bit opt-size=1:  57 <= dist <= 58
    // 64-bit opt-size=0:  58 <= dist <= 58
    // 64-bit opt-size=1:  58 <= dist <= 58
    assert_eq!(1.8014398509481984E16, ieee_parts_to_double(false, 1077, 0));
    assert_eq!(pretty(1.8014398509481984e16), "18014398509481984");
    // 32-bit opt-size=0:  57 <= dist <= 57
    // 32-bit opt-size=1:  57 <= dist <= 57
    // 64-bit opt-size=0:  58 <= dist <= 58
    // 64-bit opt-size=1:  58 <= dist <= 58
    assert_eq!(
        3.6028797018963964E16,
        ieee_parts_to_double(false, 1076, max_mantissa)
    );
    assert_eq!(pretty(3.6028797018963964e16), "36028797018963964");
    // 32-bit opt-size=0:  51 <= dist <= 52
    // 32-bit opt-size=1:  51 <= dist <= 59
    // 64-bit opt-size=0:  52 <= dist <= 52
    // 64-bit opt-size=1:  52 <= dist <= 59
    assert_eq!(2.900835519859558E-216, ieee_parts_to_double(false, 307, 0));
    assert_eq!(pretty(2.900835519859558e-216), "0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002900835519859558");
    // 32-bit opt-size=0:  51 <= dist <= 51
    // 32-bit opt-size=1:  51 <= dist <= 59
    // 64-bit opt-size=0:  52 <= dist <= 52
    // 64-bit opt-size=1:  52 <= dist <= 59
    assert_eq!(
        5.801671039719115E-216,
        ieee_parts_to_double(false, 306, max_mantissa)
    );
    assert_eq!(pretty(5.801671039719115e-216), "0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005801671039719115");

    // https://github.com/ulfjack/ryu/commit/19e44d16d80236f5de25800f56d82606d1be00b9#commitcomment-30146483
    // 32-bit opt-size=0:  49 <= dist <= 49
    // 32-bit opt-size=1:  44 <= dist <= 49
    // 64-bit opt-size=0:  50 <= dist <= 50
    // 64-bit opt-size=1:  44 <= dist <= 50
    assert_eq!(
        3.196104012172126E-27,
        ieee_parts_to_double(false, 934, 0x000FA7161A4D6E0C)
    );
    assert_eq!(pretty(3.196104012172126e-27), "0.000000000000000000000000003196104012172126");
}

#[test]
fn test_small_integers() {
    assert_eq!(pretty(9007199254740991.0), "9007199254740991"); // 2^53-1
    assert_eq!(pretty(9007199254740992.0), "9007199254740992"); // 2^53

    assert_eq!(pretty(1.0), "1");
    assert_eq!(pretty(12.0), "12");
    assert_eq!(pretty(123.0), "123");
    assert_eq!(pretty(1234.0), "1234");
    assert_eq!(pretty(12345.0), "12345");
    assert_eq!(pretty(123456.0), "123456");
    assert_eq!(pretty(1234567.0), "1234567");
    assert_eq!(pretty(12345678.0), "12345678");
    assert_eq!(pretty(123456789.0), "123456789");
    assert_eq!(pretty(1234567890.0), "1234567890");
    assert_eq!(pretty(1234567895.0), "1234567895");
    assert_eq!(pretty(12345678901.0), "12345678901");
    assert_eq!(pretty(123456789012.0), "123456789012");
    assert_eq!(pretty(1234567890123.0), "1234567890123");
    assert_eq!(pretty(12345678901234.0), "12345678901234");
    assert_eq!(pretty(123456789012345.0), "123456789012345");
    assert_eq!(pretty(1234567890123456.0), "1234567890123456");
    assert_eq!(pretty(1234567890123456.0), "1234567890123456");

    // 10^i
    assert_eq!(pretty(1.0), "1");
    assert_eq!(pretty(10.0), "10");
    assert_eq!(pretty(100.0), "100");
    assert_eq!(pretty(1000.0), "1000");
    assert_eq!(pretty(10000.0), "10000");
    assert_eq!(pretty(100000.0), "100000");
    assert_eq!(pretty(1000000.0), "1000000");
    assert_eq!(pretty(10000000.0), "10000000");
    assert_eq!(pretty(100000000.0), "100000000");
    assert_eq!(pretty(1000000000.0), "1000000000");
    assert_eq!(pretty(10000000000.0), "10000000000");
    assert_eq!(pretty(100000000000.0), "100000000000");
    assert_eq!(pretty(1000000000000.0), "1000000000000");
    assert_eq!(pretty(10000000000000.0), "10000000000000");
    assert_eq!(pretty(100000000000000.0), "100000000000000");
    assert_eq!(pretty(1000000000000000.0), "1000000000000000");

    // 10^15 + 10^i
    assert_eq!(pretty(1000000000000001.0), "1000000000000001");
    assert_eq!(pretty(1000000000000010.0), "1000000000000010");
    assert_eq!(pretty(1000000000000100.0), "1000000000000100");
    assert_eq!(pretty(1000000000001000.0), "1000000000001000");
    assert_eq!(pretty(1000000000010000.0), "1000000000010000");
    assert_eq!(pretty(1000000000100000.0), "1000000000100000");
    assert_eq!(pretty(1000000001000000.0), "1000000001000000");
    assert_eq!(pretty(1000000010000000.0), "1000000010000000");
    assert_eq!(pretty(1000000100000000.0), "1000000100000000");
    assert_eq!(pretty(1000001000000000.0), "1000001000000000");
    assert_eq!(pretty(1000010000000000.0), "1000010000000000");
    assert_eq!(pretty(1000100000000000.0), "1000100000000000");
    assert_eq!(pretty(1001000000000000.0), "1001000000000000");
    assert_eq!(pretty(1010000000000000.0), "1010000000000000");
    assert_eq!(pretty(1100000000000000.0), "1100000000000000");

    // Largest power of 2 <= 10^(i+1)
    assert_eq!(pretty(8.0), "8");
    assert_eq!(pretty(64.0), "64");
    assert_eq!(pretty(512.0), "512");
    assert_eq!(pretty(8192.0), "8192");
    assert_eq!(pretty(65536.0), "65536");
    assert_eq!(pretty(524288.0), "524288");
    assert_eq!(pretty(8388608.0), "8388608");
    assert_eq!(pretty(67108864.0), "67108864");
    assert_eq!(pretty(536870912.0), "536870912");
    assert_eq!(pretty(8589934592.0), "8589934592");
    assert_eq!(pretty(68719476736.0), "68719476736");
    assert_eq!(pretty(549755813888.0), "549755813888");
    assert_eq!(pretty(8796093022208.0), "8796093022208");
    assert_eq!(pretty(70368744177664.0), "70368744177664");
    assert_eq!(pretty(562949953421312.0), "562949953421312");
    assert_eq!(pretty(9007199254740992.0), "9007199254740992");

    // 1000 * (Largest power of 2 <= 10^(i+1))
    assert_eq!(pretty(8000.0), "8000");
    assert_eq!(pretty(64000.0), "64000");
    assert_eq!(pretty(512000.0), "512000");
    assert_eq!(pretty(8192000.0), "8192000");
    assert_eq!(pretty(65536000.0), "65536000");
    assert_eq!(pretty(524288000.0), "524288000");
    assert_eq!(pretty(8388608000.0), "8388608000");
    assert_eq!(pretty(67108864000.0), "67108864000");
    assert_eq!(pretty(536870912000.0), "536870912000");
    assert_eq!(pretty(8589934592000.0), "8589934592000");
    assert_eq!(pretty(68719476736000.0), "68719476736000");
    assert_eq!(pretty(549755813888000.0), "549755813888000");
    assert_eq!(pretty(8796093022208000.0), "8796093022208000");
}
